```{r, section13, include = FALSE}
knitr::opts_chunk$set(eval = TRUE)
```

# Advanced Operations

```{r, cathup13, include = FALSE}

library(dplyr)
library(dbplyr)
library(purrr)
library(rlang)
library(DBI)

# Class catchup
con <- DBI::dbConnect(odbc::odbc(), "Postgres Dev")
airports <- tbl(con, in_schema("datawarehouse", "airport"))
flights <- tbl(con, in_schema("datawarehouse", "vflight"))
carriers <- tbl(con, in_schema("datawarehouse", "carrier"))

```

## Simple wrapper function
*Create a function that accepts a value that is passed to a specific dplyr operation*


1. The following *dplyr* operation is fixed to only return the mean of *arrtime*.  The desire is to create a function that returns the mean of any variable passed to it.

```{r}
flights %>%
  summarise(mean = mean(arrtime, na.rm = TRUE))
```

1. Load the `rlang` library, and create a function with one argument. The function will simply return the result of `equo()`

```{r}
library(rlang)

my_mean <- function(x){
  x <- enquo(x)
  x
}

my_mean(mpg)
```

1. Add the *summarise* operation, and replace *arrtime* with *!! x*

```{r}
library(rlang)

my_mean <- function(x){
  x <- enquo(x)
  flights %>%
    summarise(mean = mean(!! x, na.rm = TRUE))
}
```

1. Test the function with *deptime*

```{r}
my_mean(deptime)
```

1. Make the function use what is passed to the *x* argument as the name of the calculation.  Replace *mean = * with *!! quo_name(x) :=* .

```{r}
my_mean <- function(x){
  x <- enquo(x)
  flights %>%
    summarise(!! quo_name(x) := mean(!! x, na.rm = TRUE))
  
}
```

1. Test the function again with *arrtime*.  The name of the variable should now by *arrtime*


```{r}
my_mean(arrtime)
```

1. Test the function with a formula: *arrtime+deptime*.

```{r}
my_mean(arrtime+deptime)
```

1. Make the function generic by adding a *.data* argument and replacing *flights* with *.data*

```{r}
my_mean <- function(.data, x){
  x <- enquo(x)
  .data %>%
    summarise(!! quo_name(x) := mean(!! x, na.rm = TRUE))
  
}
```

1. The function now behaves more like a *dplyr* verb. Start with *flights* and pipe into the function.

```{r}
flights %>%
  my_mean(arrtime)
```

1. Test the function with a different data set.  Use *mtcars* and *mpg* as the *x* argument.


```{r}
mtcars %>%
  my_mean(mpg)
```

1. Clean up the function by removing the pipe

```{r}
my_mean <- function(.data, x){
  x <- enquo(x)
  summarise(
    .data, 
    !! quo_name(x) := mean(!! x, na.rm = TRUE)
  )
}
```

1. Test again, no visible changes should be there for the results

```{r}
mtcars %>%
  my_mean(mpg)
```

1. Because the function only uses *dplyr* operations, *show_query* should work

```{r}
flights %>%
  my_mean(arrtime) %>%
  show_query()
```


## Multiple variables
*Create functions that handle a variable number of arguments. The goal of the exercise is to create an "anti-select()" function.*

1. Use *...* as the second argument of a function called *de_select*.  Inside the function use *enquos()* to parse it

```{r}
de_select <- function(.data, ...){
  vars <- enquos(...)
  vars
}
```

1. Test the function using *airports*

```{r}
airports %>%
  de_select(airport, airportname)

```

1. Add a step to the function that iterates through each quosure and prefixes a minus sign to tell *select()* to drop that specific field.  Use *map()* for the iteration, and *expr()* to create the prefixed expression.

```{r}
de_select <- function(.data, ...){
  vars <- enquos(...)
  vars <- map(vars, ~ expr(- !! .x))
  vars
}
```

1. Run the same test to view the new results

```{r}
airports %>%
  de_select(airport, airportname)

```

1. Add the *select()* step.  Use *!!!* to parse the *vars* variable inside *select()*

```{r}
de_select <- function(.data, ...){
  vars <- enquos(...)
  vars <- map(vars, ~ expr(- !! .x))
  select(
    .data,
    !!! vars
  )
}
```

1. Run the test again, this time the operation will take place.  

```{r}
airports %>%
  de_select(airport, airportname)
```

1. Add a *show_query()* step to see the resulting SQL

```{r}
airports %>%
  de_select(airport, airportname) %>%
  show_query()
```

1. Test the function with a different data set, such as *mtcars*

```{r}
mtcars %>%
  de_select(mpg, wt, am)
```

```{r}
dbDisconnect(con)
```
